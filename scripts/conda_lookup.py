# Generated by chatgpt
import json
import re
from collections import deque, defaultdict

import requests

try:
    import zstandard as zstd  # pip install zstandard
except ImportError:
    zstd = None


DEP_NAME_RE = re.compile(r"^([A-Za-z0-9_.-]+)")

def fetch_repodata(channel: str, subdir: str, prefer_zst: bool = True) -> dict:
    """
    Fetch and parse repodata for a given channel/subdir.
    """
    base = f"https://conda.anaconda.org/{channel}/{subdir}/repodata.json"
    if prefer_zst:
        zst_url = base + ".zst"
        r = requests.get(zst_url, timeout=120)
        if r.ok:
            if zstd is None:
                raise RuntimeError("repodata.json.zst found but 'zstandard' not installed. pip install zstandard")
            dctx = zstd.ZstdDecompressor()
            data = dctx.decompress(r.content)
            return json.loads(data.decode("utf-8"))
    r = requests.get(base, timeout=120)
    r.raise_for_status()
    return r.json()

def iter_package_records(repodata: dict):
    """
    Yield (name, depends_list) for each build record in repodata.json.
    repodata may have 'packages' (tar.bz2) and/or 'packages.conda'.
    """
    for section in ("packages", "packages.conda"):
        pkgs = repodata.get(section, {})
        for _, rec in pkgs.items():
            name = rec.get("name")
            depends = rec.get("depends", []) or []
            if name:
                yield name, depends

def dep_name(dep_spec: str) -> str | None:
    """
    Extract dependency package name from a conda dependency string like:
      'numpy >=1.26'
      'python 3.11.*'
    """
    m = DEP_NAME_RE.match(dep_spec.strip())
    return m.group(1).lower() if m else None

def transitive_dependents(target: str, channel: str, subdirs: list[str]) -> set[str]:
    target = target.lower()

    # Build reverse adjacency: dep_name -> set(of package names that require it)
    rdeps = defaultdict(set)

    for subdir in subdirs:
        repodata = fetch_repodata(channel, subdir)
        for pkg_name, depends in iter_package_records(repodata):
            p = pkg_name.lower()
            for d in depends:
                dn = dep_name(d)
                if dn:
                    rdeps[dn].add(p)

    # BFS on reverse graph
    seen = set([target])
    out = set()
    q = deque([target])

    while q:
        cur = q.popleft()
        for parent in rdeps.get(cur, ()):
            if parent not in seen:
                seen.add(parent)
                out.add(parent)
                q.append(parent)

    return out

if __name__ == "__main__":
    # Example: reverse-transitive dependents of numpy on conda-forge for linux-64 + noarch
    for channel in ["conda-forge", "bioconda"]:
        deps = transitive_dependents("tskit", channel=channel, subdirs=["linux-64", "noarch"])
        print(f"{len(deps)} transitive dependents (package names) in {channel}:")
        for name in deps:
            print(" ", name)

